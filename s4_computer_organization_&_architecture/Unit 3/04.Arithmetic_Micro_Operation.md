# ğŸ“˜ Arithmetic Micro-Operations

---

# 1ï¸âƒ£ What is a Micro-Operation?

A **micro-operation** is the smallest operation performed on data stored inside CPU registers.  
It completes in **one clock cycle** and is controlled by the **Control Unit**.

## ğŸ’¡ Understanding It Simply

A full instruction like:

```assembly
ADD R1, R2
```

is broken into multiple tiny internal steps.

> Each tiny internal step = **Micro-operation**

---

## ğŸ”¹ Types of Micro-Operations

1. Register Transfer  
2. Arithmetic  
3. Logic  
4. Shift  

---

## ğŸ”¹ Register Transfer Micro-Operation

### Example

```
R2 â† R1
```

### Meaning

- Copy content of **R1** into **R2**
- **R1 remains unchanged**

### Example Execution

If:

```
R1 = 1010
```

After execution:

```
R2 = 1010
```

---

# 2ï¸âƒ£ Arithmetic Micro-Operations

Arithmetic micro-operations perform mathematical operations on binary numbers stored in registers.

---

## ğŸ”¹ Complete List with Meaning

| Operation | RTL Notation | Meaning |
|------------|-------------|----------|
| Addition | `R3 â† R1 + R2` | Add R1 and R2 |
| Subtraction | `R3 â† R1 - R2` | Subtract R2 from R1 |
| Increment | `R1 â† R1 + 1` | Add 1 |
| Decrement | `R1 â† R1 - 1` | Subtract 1 |
| Add with Carry | `R3 â† R1 + R2 + Cin` | Add including carry |
| Subtract with Borrow | `R3 â† R1 - R2 - Bin` | Subtract including borrow |
| Negate | `R2 â† RÌ„2 + 1` | 2â€™s complement |
| Negate & Add | `R3 â† R1 + RÌ„2 + 1` | Subtraction using 2â€™s complement |

---

## ğŸ”¹ Example 1: Addition

```
R1 = 0110 (6)
R2 = 0011 (3)

R3 = R1 + R2
```

```
  0110
+ 0011
-------
  1001  (9)
```

---

## ğŸ”¹ Example 2: Subtraction (Using 2â€™s Complement)

```
R1 = 0110 (6)
R2 = 0011 (3)
```

### Step 1: Take 2â€™s Complement of R2

```
0011 â†’ invert â†’ 1100
1100 + 1 = 1101
```

### Step 2: Add

```
  0110
+ 1101
-------
 10011
```

Ignore the carry:

```
0011 = 3
```

âœ” Correct

---

# 3ï¸âƒ£ Half Adder (HA)

A **Half Adder** adds two 1-bit numbers.

---

## ğŸ”¹ Truth Table

| A | B | Sum | Carry |
|---|---|-----|--------|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

---

## ğŸ”¹ Boolean Equations

```
Sum = A âŠ• B
Carry = A Â· B
```

---

## ğŸ”¹ Dry Run: 1 + 1

```
A = 1
B = 1

Sum = 1 âŠ• 1 = 0
Carry = 1 Â· 1 = 1
```

Output:

```
10 (binary) = 2
```

---

## ğŸ”¹ Limitation

- Half Adder cannot accept carry input  
- So it cannot be used for multi-bit addition except for LSB  

---

# 4ï¸âƒ£ Full Adder (FA)

A **Full Adder** adds:

```
A + B + Cin
```

---

## ğŸ”¹ Important Pattern

- Sum = 1 when odd number of inputs are 1  
- Cout = 1 when two or more inputs are 1  

---

## ğŸ”¹ Boolean Expressions

```
Sum = A âŠ• B âŠ• Cin
Cout = AB + BCin + ACin
```

---

## ğŸ”¹ Dry Run Example

### A = 1, B = 1, Cin = 1

Step 1:

```
1 âŠ• 1 = 0
0 âŠ• 1 = 1
Sum = 1
```

Step 2:

```
Cout = (1Â·1) + (1Â·1) + (1Â·1)
     = 1 + 1 + 1
     = 1
```

Result:

```
Sum = 1, Cout = 1 â†’ 11 (3)
```

---

# 5ï¸âƒ£ Ripple Carry Adder (4-bit)

- Multiple Full Adders connected together  
- Carry moves from LSB to MSB  
- Called "Ripple" because carry propagates stage by stage  

---

## ğŸ”¹ Example: 6 + 5

```
6 = 0110
5 = 0101
```

### FA0

```
0 + 1 + 0 = 1 carry 0
```

### FA1

```
1 + 0 + 0 = 1 carry 0
```

### FA2

```
1 + 1 + 0 = 0 carry 1
```

### FA3

```
0 + 0 + 1 = 1 carry 0
```

### Final Result

```
1011 = 11
```

---

# 6ï¸âƒ£ Binary Adder-Subtractor

Uses:

- XOR gates  
- Mode input M  

---

## ğŸ”¹ Working

```
M = 0 â†’ Addition
M = 1 â†’ Subtraction
```

### XOR Trick

```
B âŠ• 0 = B
B âŠ• 1 = BÌ„
```

---

## ğŸ”¹ Dry Run: 6 - 3

```
A = 0110
B = 0011
M = 1
```

Invert B:

```
1100
```

Add 1 via Cin:

```
  0110
+ 1100
+    1
--------
  0011
```

âœ” Result = 3

---

# 7ï¸âƒ£ Arithmetic Circuit (Using S1, S0, Cin)

Operations are selected using control lines.

---

## ğŸ”¹ Function Table

| S1 | S0 | Cin | Operation |
|----|----|-----|------------|
| 0 | 0 | 0 | A |
| 0 | 0 | 1 | A + 1 |
| 0 | 1 | 0 | A + B |
| 0 | 1 | 1 | A + B + 1 |
| 1 | 0 | 0 | A + BÌ„ |
| 1 | 0 | 1 | A - B |
| 1 | 1 | 0 | A - 1 |
| 1 | 1 | 1 | A |

---

# 8ï¸âƒ£ Carry vs Overflow

| Carry | Overflow |
|--------|-----------|
| Used in Unsigned arithmetic | Used in Signed arithmetic |
| Carry out of MSB | Carry into MSB â‰  Carry out of MSB |

---

## ğŸ”¹ Overflow Example (4-bit Signed)

```
  0111  (7)
+ 0011  (3)
--------
  1010
```

Result = -6 (incorrect for signed addition)

âœ” Overflow occurred

---

# 9ï¸âƒ£ 2â€™s Complement

To represent -5 in 4-bit:

```
5 = 0101
Invert â†’ 1010
Add 1 â†’ 1011
```

```
1011 = -5
```

---

# ğŸ”Ÿ Practice Example: 9 + 6 (4-bit)

```
9 = 1001
6 = 0110
```

```
 1001
+0110
-------
 1111
```

âœ” 15

---

# âœ… Final Concept Summary

| Concept | Important Idea |
|----------|---------------|
| Half Adder | No carry input |
| Full Adder | Handles carry |
| Ripple Carry | Slow due to carry propagation |
| Adder-Subtractor | XOR used for inversion |
| 2â€™s Complement | Used for subtraction |
| Overflow | Signed error detection |

---
