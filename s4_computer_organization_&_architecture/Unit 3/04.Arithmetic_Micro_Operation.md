1ï¸âƒ£ What is a Micro-Operation?

A micro-operation is the smallest operation performed on data stored inside CPU registers.
It completes in one clock cycle and is controlled by the Control Unit.

Think of it like this:

A full instruction like ADD R1, R2 is broken into multiple tiny internal steps.
Each tiny step = micro-operation.

ğŸ”¹ Types of Micro-Operations

Register Transfer

Arithmetic

Logic

Shift

ğŸ”¹ Register Transfer Micro-Operation

Example:

R2 â† R1

Meaning:

Copy content of R1 into R2

R1 remains unchanged

If:

R1 = 1010

After:

R2 = 1010
2ï¸âƒ£ Arithmetic Micro-Operations

Arithmetic micro-operations perform mathematical operations on binary numbers stored in registers.

ğŸ”¹ Complete List with Meaning
Operation	RTL Notation	Meaning
Addition	R3 â† R1 + R2	Add R1 and R2
Subtraction	R3 â† R1 - R2	Subtract R2 from R1
Increment	R1 â† R1 + 1	Add 1
Decrement	R1 â† R1 - 1	Subtract 1
Add with Carry	R3 â† R1 + R2 + Cin	Add including carry
Subtract with Borrow	R3 â† R1 - R2 - Bin	Subtract including borrow
Negate	R2 â† RÌ„2 + 1	2â€™s complement
Negate & Add	R3 â† R1 + RÌ„2 + 1	Subtraction using 2â€™s complement
ğŸ”¹ Example 1: Addition
R1 = 0110 (6)
R2 = 0011 (3)

R3 = R1 + R2
  0110
+ 0011
-------
  1001  (9)
ğŸ”¹ Example 2: Subtraction (Using 2â€™s Complement)
R1 = 0110 (6)
R2 = 0011 (3)

Step 1: Take 2â€™s complement of R2

0011 â†’ invert â†’ 1100
1100 + 1 = 1101

Step 2: Add

  0110
+ 1101
-------
 10011

Ignore carry â†’ 0011 = 3

Correct âœ“

3ï¸âƒ£ Half Adder (HA)

A Half Adder adds two 1-bit numbers.

ğŸ”¹ Circuit Representation
4
ğŸ”¹ Truth Table
A	B	Sum	Carry
0	0	0	0
0	1	1	0
1	0	1	0
1	1	0	1
ğŸ”¹ Boolean Equations
Sum = A âŠ• B
Carry = A Â· B
ğŸ”¹ Dry Run: 1 + 1
A = 1
B = 1

Sum = 1 âŠ• 1 = 0
Carry = 1 Â· 1 = 1

Output:

10 (binary) = 2
ğŸ”¹ Limitation

Half Adder cannot accept carry input.
So it cannot be used for multi-bit addition except for LSB.

4ï¸âƒ£ Full Adder (FA)

A Full Adder adds:

A + B + Cin
ğŸ”¹ Circuit Diagram
4
ğŸ”¹ Truth Table Pattern

Important Pattern:

Sum = 1 when odd number of 1s

Cout = 1 when two or more inputs are 1

ğŸ”¹ Boolean Expressions
Sum = A âŠ• B âŠ• Cin
Cout = AB + BCin + ACin
ğŸ”¹ Dry Run Example: A=1, B=1, Cin=1

Step 1:

1 âŠ• 1 = 0
0 âŠ• 1 = 1
Sum = 1

Step 2:

Cout = (1Â·1) + (1Â·1) + (1Â·1)
      = 1 + 1 + 1
      = 1

Result:

Sum=1, Cout=1 â†’ 11 (3)
5ï¸âƒ£ Ripple Carry Adder (4-bit)

Multiple Full Adders connected together.

Carry moves from LSB to MSB â€” like a ripple in water.

ğŸ”¹ Diagram
4
ğŸ”¹ Example: 6 + 5
6 = 0110
5 = 0101
FA0
0+1+0 = 1 carry 0
FA1
1+0+0 = 1 carry 0
FA2
1+1+0 = 0 carry 1
FA3
0+0+1 = 1 carry 0

Result:

1011 = 11
6ï¸âƒ£ Binary Adder-Subtractor

Uses:

XOR gates

Mode input M

ğŸ”¹ Circuit
4
ğŸ”¹ Working
M = 0 â†’ Addition
M = 1 â†’ Subtraction

XOR trick:

B âŠ• 0 = B
B âŠ• 1 = BÌ„
ğŸ”¹ Dry Run: 6 - 3
A = 0110
B = 0011
M = 1

Invert B:

1100

Add 1 via Cin:

  0110
+ 1100
+    1
--------
  0011

Result = 3 âœ“

7ï¸âƒ£ Arithmetic Circuit (Using S1, S0, Cin)

It selects operation using control lines.

ğŸ”¹ Function Table
S1	S0	Cin	Operation
0	0	0	A
0	0	1	A+1
0	1	0	A+B
0	1	1	A+B+1
1	0	0	A + BÌ„
1	0	1	A - B
1	1	0	A-1
1	1	1	A
8ï¸âƒ£ Carry vs Overflow
Carry	Overflow
Unsigned	Signed
Carry out of MSB	MSB carry in â‰  carry out
ğŸ”¹ Overflow Example

4-bit signed:

7 = 0111
+ 3 = 0011
------------
 1010

Result = -6 (wrong for signed)

Overflow occurred âœ“

9ï¸âƒ£ 2â€™s Complement Deep Explanation

To represent -5 in 4-bit:

5 = 0101
Invert â†’ 1010
Add 1 â†’ 1011

So:

1011 = -5
ğŸ”Ÿ Practice Example: 9 + 6 (4-bit)
9 = 1001
6 = 0110

Add:

 1001
+0110
-------
 1111

= 15 âœ“

âœ… Final Concept Summary
Concept	Important Idea
Half Adder	No carry input
Full Adder	Handles carry
Ripple Carry	Slow due to carry propagation
Adder-Subtractor	XOR used for inversion
2â€™s Complement	Used for subtraction
Overflow	Signed error detection
